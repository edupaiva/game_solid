1ï¸âƒ£ AplicaÃ§Ã£o do Clean Code
âœ… Nomes descritivos â†’ lista virou nova_palavra_oculta, pessoa_escondida virou palavra_oculta, etc.
âœ… Quebra de responsabilidade â†’ O cÃ³digo estÃ¡ dividido em mÃ©todos dentro da classe JogoForca.
âœ… Removemos repetiÃ§Ãµes â†’ A lÃ³gica de atualizaÃ§Ã£o da palavra oculta foi encapsulada em atualizar_palavra_oculta().

2ï¸âƒ£ AplicaÃ§Ã£o de SOLID
âœ” S (Single Responsibility Principle - SRP) â†’ Cada mÃ©todo tem apenas uma responsabilidade (verificar letras, atualizar palavra, rodar o jogo).
âœ” O (Open/Closed Principle - OCP) â†’ O cÃ³digo estÃ¡ aberto para extensÃ£o (podemos adicionar mais funcionalidades), mas fechado para modificaÃ§Ã£o.
âœ” L (Liskov Substitution Principle - LSP) â†’ NÃ£o aplicÃ¡vel diretamente, mas o cÃ³digo mantÃ©m consistÃªncia caso seja estendido.
âœ” I (Interface Segregation Principle - ISP) â†’ Como usamos uma Ãºnica classe, nÃ£o hÃ¡ interfaces aqui.
âœ” D (Dependency Inversion Principle - DIP) â†’ O jogo nÃ£o depende de implementaÃ§Ãµes especÃ­ficas, o que facilita melhorias futuras.


ğŸ›  BenefÃ­cios do cÃ³digo refatorado
ğŸš€ Modular e reutilizÃ¡vel â†’ Podemos reutilizar a classe JogoForca em outro sistema sem mudar nada.
ğŸ’¡ LegÃ­vel â†’ FÃ¡cil entender o que cada mÃ©todo faz.
ğŸ›  FÃ¡cil de manter â†’ Qualquer mudanÃ§a pode ser feita sem afetar outras partes do cÃ³digo.

